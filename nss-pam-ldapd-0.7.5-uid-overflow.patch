From a9deed36b25ba4d7ddedd6259f7e48f0043d4ce3 Mon Sep 17 00:00:00 2001
From: Jakub Hrozek <jhrozek@redhat.com>
Date: Wed, 31 Aug 2011 10:55:19 +0200
Subject: [PATCH] Do not overflow large 32bit UIDs

Use new strotouid()/strtogid() calls for converting strings to integers.
Use an explicit base of 10 for strtouid()/strtogid() calls
---
 configure.ac   |    6 ++++++
 nslcd/cfg.c    |   10 ++++++----
 nslcd/common.c |   22 ++++++++++++++++++++++
 nslcd/common.h |    6 ++++++
 nslcd/group.c  |    9 ++++++++-
 nslcd/passwd.c |   18 ++++++++++++++++--
 6 files changed, 64 insertions(+), 7 deletions(-)

diff --git a/configure.ac b/configure.ac
index 43effa4..c458bbe 100644
--- a/configure.ac
+++ b/configure.ac
@@ -261,12 +261,18 @@ AC_CHECK_FUNCS(sigaction)
 AC_CHECK_FUNCS(snprintf)
 AC_CHECK_FUNCS(gethostbyname)
 AC_SEARCH_LIBS(socket,socket)
+AC_CHECK_FUNCS([strtoul strtoull])
 
 # checks for types
 AC_C_CONST
 AC_TYPE_MODE_T
 AC_TYPE_SIZE_T
 AC_TYPE_UID_T
+AC_CHECK_SIZEOF(unsigned int)
+AC_CHECK_SIZEOF(unsigned long int)
+AC_CHECK_SIZEOF(unsigned long long int)
+AC_CHECK_SIZEOF(uid_t)
+AC_CHECK_SIZEOF(gid_t)
 
 # check for support for the __thread keyword
 AC_CACHE_CHECK([whether $CC supports '__thread'], [mn_cv_c___thread_supported],
diff --git a/nslcd/cfg.c b/nslcd/cfg.c
index 4455a1e..c3c82b0 100644
--- a/nslcd/cfg.c
+++ b/nslcd/cfg.c
@@ -452,8 +452,9 @@ static void get_uid(const char *filename,int lnr,
   char *tmp;
   check_argumentcount(filename,lnr,keyword,get_token(line,token,sizeof(token))!=NULL);
   /* check if it is a valid numerical uid */
-  *var=(uid_t)strtol(token,&tmp,0);
-  if ((*token!='\0')&&(*tmp=='\0'))
+  errno=0;
+  *var=strtouid(token,&tmp,10);
+  if ((*token!='\0')&&(*tmp=='\0')&&(errno==0))
     return;
   /* find by name */
   pwent=getpwnam(token);
@@ -477,8 +478,9 @@ static void get_gid(const char *filename,int lnr,
   char *tmp;
   check_argumentcount(filename,lnr,keyword,get_token(line,token,sizeof(token))!=NULL);
   /* check if it is a valid numerical gid */
-  *var=(gid_t)strtol(token,&tmp,0);
-  if ((*token!='\0')&&(*tmp=='\0'))
+  errno=0;
+  *var=strtogid(token,&tmp,10);
+  if ((*token!='\0')&&(*tmp=='\0')&&(errno==0))
     return;
   /* find by name */
   grent=getgrnam(token);
diff --git a/nslcd/common.c b/nslcd/common.c
index cb22459..2d2f0df 100644
--- a/nslcd/common.c
+++ b/nslcd/common.c
@@ -147,3 +147,25 @@ int read_address(TFILE *fp,char *addr,int *addrlen,int *af)
   /* we're done */
   return 0;
 }
+
+/* provide a strtoui() implementation, similar to strtoul() but returning
+   an range-checked unsigned int instead */
+uint32_t strtoid(const char *nptr,char **endptr,int base)
+{
+  long long val;
+
+  val=strtoll(nptr,endptr,base);
+  if (val>UINT32_MAX)
+  {
+    errno=ERANGE;
+    return UINT32_MAX;
+  }
+  else if (val<0)
+  {
+    errno=EINVAL;
+    return UINT32_MAX;
+  }
+
+  /* If errno was set, we'll pass it back as-is */
+  return (uint32_t) val;
+}
diff --git a/nslcd/common.h b/nslcd/common.h
index fafa25a..300b37f 100644
--- a/nslcd/common.h
+++ b/nslcd/common.h
@@ -25,6 +25,7 @@
 #define _SERVER_COMMON_H 1
 
 #include <errno.h>
+#include <stdint.h>
 
 #include "nslcd.h"
 #include "common/nslcd-prot.h"
@@ -94,6 +95,11 @@ MYLDAP_ENTRY *uid2entry(MYLDAP_SESSION *session,const char *uid);
 /* transforms the uid into a DN by doing an LDAP lookup */
 MUST_USE char *uid2dn(MYLDAP_SESSION *session,const char *uid,char *buf,size_t buflen);
 
+#define strtouid (uid_t)strtoid
+#define strtogid (uid_t)strtoid
+
+uint32_t strtoid(const char *nptr,char **endptr,int base);
+
 /* these are the functions for initialising the database specific
    modules */
 void alias_init(void);
diff --git a/nslcd/group.c b/nslcd/group.c
index 14f7251..49bb9cc 100644
--- a/nslcd/group.c
+++ b/nslcd/group.c
@@ -252,13 +252,20 @@ static int write_group(TFILE *fp,MYLDAP_ENTRY *entry,const char *reqname,
     }
     for (numgids=0;(gidvalues[numgids]!=NULL)&&(numgids<MAXGIDS_PER_ENTRY);numgids++)
     {
-      gids[numgids]=(gid_t)strtol(gidvalues[numgids],&tmp,0);
+      errno=0;
+      gids[numgids]=strtogid(gidvalues[numgids],&tmp,10);
       if ((*(gidvalues[numgids])=='\0')||(*tmp!='\0'))
       {
         log_log(LOG_WARNING,"group entry %s contains non-numeric %s value",
                             myldap_get_dn(entry),attmap_group_gidNumber);
         return 0;
       }
+      else if (errno!=0)
+      {
+        log_log(LOG_WARNING,"group entry %s contains too large %s value",
+                            myldap_get_dn(entry),attmap_group_gidNumber);
+        return 0;
+      }
     }
   }
   /* get group passwd (userPassword) (use only first entry) */
diff --git a/nslcd/passwd.c b/nslcd/passwd.c
index f3e51e6..22e8bd6 100644
--- a/nslcd/passwd.c
+++ b/nslcd/passwd.c
@@ -338,13 +338,20 @@ static int write_passwd(TFILE *fp,MYLDAP_ENTRY *entry,const char *requser,
     }
     for (numuids=0;(numuids<MAXUIDS_PER_ENTRY)&&(tmpvalues[numuids]!=NULL);numuids++)
     {
-      uids[numuids]=(uid_t)strtol(tmpvalues[numuids],&tmp,0);
+      errno=0;
+      uids[numuids]=strtouid(tmpvalues[numuids],&tmp,10);
       if ((*(tmpvalues[numuids])=='\0')||(*tmp!='\0'))
       {
         log_log(LOG_WARNING,"passwd entry %s contains non-numeric %s value",
                             myldap_get_dn(entry),attmap_passwd_uidNumber);
         return 0;
       }
+      else if (errno!=0)
+      {
+        log_log(LOG_WARNING,"passwd entry %s contains too large %s value",
+                            myldap_get_dn(entry),attmap_passwd_uidNumber);
+        return 0;
+      }
     }
   }
   /* get the gid for this entry */
@@ -355,13 +362,20 @@ static int write_passwd(TFILE *fp,MYLDAP_ENTRY *entry,const char *requser,
                         myldap_get_dn(entry),attmap_passwd_gidNumber);
     return 0;
   }
-  gid=(gid_t)strtol(gidbuf,&tmp,0);
+  errno=0;
+  gid=strtogid(gidbuf,&tmp,10);
   if ((gidbuf[0]=='\0')||(*tmp!='\0'))
   {
     log_log(LOG_WARNING,"passwd entry %s contains non-numeric %s value",
                         myldap_get_dn(entry),attmap_passwd_gidNumber);
     return 0;
   }
+  else if (errno!=0)
+  {
+    log_log(LOG_WARNING,"passwd entry %s contains too large %s value",
+                        myldap_get_dn(entry),attmap_passwd_uidNumber);
+    return 0;
+  }
   /* get the gecos for this entry */
   attmap_get_value(entry,attmap_passwd_gecos,gecos,sizeof(gecos));
   /* get the home directory for this entry */
-- 
1.7.6.4

