diff -up nss-pam-ldapd-0.7.5/common/tio.c.tiobug nss-pam-ldapd-0.7.5/common/tio.c
--- nss-pam-ldapd-0.7.5/common/tio.c.tiobug	2016-01-19 13:46:39.195248839 +0100
+++ nss-pam-ldapd-0.7.5/common/tio.c	2016-01-19 13:46:39.205248868 +0100
@@ -90,7 +90,7 @@ static inline void tio_get_deadline(stru
     return;
   }
   deadline->tv_sec+=timeout/1000;
-  deadline->tv_sec+=(timeout%1000)*1000;
+  deadline->tv_usec+=(timeout%1000)*1000;
 }
 
 /* update the timeout to the value that is remaining before deadline
@@ -161,6 +161,7 @@ static int tio_wait(TFILE *fp,int readfd
   int rv;
   while (1)
   {
+    /* figure out the time we need to wait */
     if ((timeout=tio_time_remaining(deadline))<0)
     {
       errno=ETIME;
@@ -192,10 +193,10 @@ static int tio_wait(TFILE *fp,int readfd
       errno=ETIME;
       return -1;
     }
-    else if (errno!=EINTR)
+    else if ((errno!=EINTR)&&(errno!=EAGAIN))
       /* some error ocurred */
       return -1;
-    /* we just try again on EINTR */
+    /* we just try again on EINTR or EAGAIN */
   }
 }
 
@@ -303,7 +304,7 @@ int tio_skip(TFILE *fp, size_t count)
 }
 
 /* Read all available data from the stream and empty the read buffer. */
-int tio_skipall(TFILE *fp)
+int tio_skipall(TFILE *fp,int skiptimeout)
 {
   struct pollfd fds[1];
   int rv;
@@ -323,7 +324,7 @@ int tio_skipall(TFILE *fp)
     /* see if any data is available */
     fds[0].fd=fp->fd;
     fds[0].events=POLLIN;
-    rv=poll(fds,1,SKIP_TIMEOUT);
+    rv=poll(fds,1,skiptimeout);
     /* check the poll() result */
     if (rv==0)
       return 0; /* no file descriptor ready */
@@ -425,7 +426,7 @@ static int tio_flush_nonblock(TFILE *fp)
   rv=poll(fds,1,0);
   /* check if any file descriptors were ready (timeout) or we were
      interrupted */
-  if ((rv==0)||((rv<0)&&(errno==EINTR)))
+  if ((rv==0)||((rv<0)&&((errno==EINTR)||(errno==EAGAIN))))
     return 0;
   /* any other errors? */
   if (rv<0)
diff -up nss-pam-ldapd-0.7.5/common/tio.h.tiobug nss-pam-ldapd-0.7.5/common/tio.h
--- nss-pam-ldapd-0.7.5/common/tio.h.tiobug	2016-01-19 13:46:39.195248839 +0100
+++ nss-pam-ldapd-0.7.5/common/tio.h	2016-01-19 13:46:39.205248868 +0100
@@ -59,7 +59,7 @@ int tio_read(TFILE *fp,void *buf,size_t
 int tio_skip(TFILE *fp,size_t count);
 
 /* Read all available data from the stream and empty the read buffer. */
-int tio_skipall(TFILE *fp);
+int tio_skipall(TFILE *fp,int skiptimeout);
 
 /* Write the specified buffer to the stream. */
 int tio_write(TFILE *fp,const void *buf,size_t count);
diff -up nss-pam-ldapd-0.7.5/nss/common.h.tiobug nss-pam-ldapd-0.7.5/nss/common.h
--- nss-pam-ldapd-0.7.5/nss/common.h.tiobug	2016-01-19 13:46:39.203248862 +0100
+++ nss-pam-ldapd-0.7.5/nss/common.h	2016-01-19 13:48:18.976540979 +0100
@@ -24,12 +24,21 @@
 #define _NSS_COMMON_H 1
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <nss.h>
 
 #include "nslcd.h"
 #include "common/nslcd-prot.h"
 #include "compat/attrs.h"
 
+#ifdef NSS_FLAVOUR_SOLARIS
+#include "solnss.h"
+#endif /* NSS_FLAVOUR_SOLARIS */
+
+/* skip timeout determines the maximum time to wait when closing the
+   connection and reading whatever data that is available */
+#define SKIP_TIMEOUT 500
+
 /* These are macros for handling read and write problems, they are
    NSS specific due to the return code so are defined here. They
    genrally close the open file, set an error code and return with
@@ -66,6 +75,25 @@
   fp=NULL; \
   return NSS_STATUS_NOTFOUND;
 
+/* These are some general macros that are used to build parts of the
+   genral macros below. */
+
+/* extra definitions we need (nothing for Glibc) */
+#define NSS_EXTRA_DEFS ;
+
+/* check validity of passed buffer (Glibc flavour) */
+#define NSS_BUFCHECK \
+  if (buffer==NULL) \
+  { \
+    *errnop=EINVAL; \
+    return NSS_STATUS_UNAVAIL; \
+  } \
+  if (buflen==0) \
+  { \
+    *errnop=ERANGE; \
+    return NSS_STATUS_TRYAGAIN; \
+  }
+
 /* The following macros to automatically generate get..byname(),
    get..bynumber(), setent(), getent() and endent() function
    bodies. These functions have very common code so this can
@@ -83,25 +111,17 @@
   TFILE *fp; \
   int32_t tmpint32; \
   enum nss_status retv; \
-  /* check that we have a valid buffer */ \
-  if ((buffer==NULL)) \
-  { \
-      *errnop=EINVAL; \
-      return NSS_STATUS_UNAVAIL; \
-  } \
-  if (buflen==0) \
-  { \
-    *errnop=ERANGE; \
-    return NSS_STATUS_TRYAGAIN; \
-  } \
+  NSS_EXTRA_DEFS; \
+  NSS_BUFCHECK; \
   /* open socket and write request */ \
   NSLCD_REQUEST(fp,action,writefn); \
   /* read response */ \
   READ_RESPONSE_CODE(fp); \
   retv=readfn; \
   /* close socket and we're done */ \
-  if ((retv==NSS_STATUS_SUCCESS)||(retv==NSS_STATUS_TRYAGAIN)) { \
-    (void)tio_skipall(fp); /* read any buffered data */ \
+  if ((retv==NSS_STATUS_SUCCESS)||(retv==NSS_STATUS_TRYAGAIN)) \
+  { \
+    (void)tio_skipall(fp,SKIP_TIMEOUT); \
     (void)tio_close(fp); \
   } \
   return retv;
@@ -137,24 +157,8 @@
 #define NSS_GETENT(fp,action,readfn) \
   int32_t tmpint32; \
   enum nss_status retv; \
-  /* check that we have a valid buffer */ \
-  if ((buffer==NULL)||(buflen=0)) \
-  { \
-      /* close stream */ \
-      if (fp!=NULL) \
-      { \
-        (void)tio_close(fp); \
-        fp=NULL; \
-      } \
-      /* indicate error */ \
-      *errnop=EINVAL; \
-      return NSS_STATUS_UNAVAIL; \
-  } \
-  if (buflen==0) \
-  { \
-    *errnop=ERANGE; \
-    return NSS_STATUS_TRYAGAIN; \
-  } \
+  NSS_EXTRA_DEFS; \
+  NSS_BUFCHECK; \
   /* check that we have a valid file descriptor */ \
   if (fp==NULL) \
   { \
@@ -172,6 +176,9 @@
     /* if we have a full buffer try to reset the stream */ \
     if (tio_reset(fp)) \
     { \
+      /* reset failed, we close and give up with a permanent error \
+         because we cannot retry just the getent() call because it \
+         may not be only the first entry that failed */ \
       tio_close(fp); \
       fp=NULL; \
       /* fail with permanent error to prevent retries */ \
@@ -188,7 +195,7 @@
 #define NSS_ENDENT(fp) \
   if (fp!=NULL) \
   { \
-    (void)tio_skipall(fp); \
+    (void)tio_skipall(fp,SKIP_TIMEOUT); \
     (void)tio_close(fp); \
     fp=NULL; \
   } \
